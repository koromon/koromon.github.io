<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="we shall never surrender">
<meta property="og:type" content="website">
<meta property="og:title" content="Koromon&#39;s Blog">
<meta property="og:url" content="https://koromon.github.io/index.html">
<meta property="og:site_name" content="Koromon&#39;s Blog">
<meta property="og:description" content="we shall never surrender">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Koromon&#39;s Blog">
<meta name="twitter:description" content="we shall never surrender">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Koromon'
    },
    algolia: {
      applicationID: 'ORP53ZDIIW',
      apiKey: '82ca70fb1b2a8d59466a2117e2b8bdf6',
      indexName: 'Blog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://koromon.github.io/"/>





  <title>Koromon's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?f93585680dfe31415c75d223c97af860";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Koromon's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/23/20180123每日小结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/23/20180123每日小结/" itemprop="url">20180123每日小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T20:15:27+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="今天完成的事情："><a href="#今天完成的事情：" class="headerlink" title="今天完成的事情："></a>今天完成的事情：</h2><ul>
<li>完成了 js 原型链以及继承的实现文章。</li>
<li>简单了解了 mac 下创建脚本的方式。</li>
</ul>
<h2 id="明天计划的事情："><a href="#明天计划的事情：" class="headerlink" title="明天计划的事情："></a>明天计划的事情：</h2><p>学习 node 中的单元测试知识以及常见的 UI 测试工具。</p>
<h2 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h2><ul>
<li>对于 <code>Function</code> 和 <code>Object</code> 之间的关系有些模糊，于是谷歌搜索，并自己实际操作访问一下它们的 <code>prototype</code> 和 <code>__proto__</code> 属性，然后写了文章总结，至此对于它们之间的关系也是比较清楚了。</li>
<li>对于某些命令要在终端行执行几次不同的命令，比较麻烦，通过搜索了解创建脚本的简单方式。</li>
</ul>
<h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><p>一、 熟悉了 js 原型链以及继承的实现方式。</p>
<ul>
<li><a href="https://koromon.github.io/2018/01/22/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%AE%80%E4%BB%8B/">js原型链简介</a></li>
<li><a href="https://koromon.github.io/2018/01/23/js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">js实现继承的几种方式</a></li>
</ul>
<p>二、 mac 创建简单脚本</p>
<ol>
<li><p>创建一个 <code>xxx.sh</code> 文件，文件内容如下（#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#! /bin/bash  </div><div class="line">#可以在这里输入你要在终端执行一系列的命令</div></pre></td></tr></table></figure>
</li>
<li><p>从终端进入刚才保存文件的目录，执行 <code>chmod +x xxx.sh</code>，这一步是为了赋予这个文件运行的权限</p>
</li>
<li>直接在终端执行 <code>./xx.sh</code>，<code>./</code>这个前缀告诉系统说，就在当前目录找命令。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/23/js实现继承的几种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/23/js实现继承的几种方式/" itemprop="url">js实现继承的几种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-23T18:29:05+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写完了上一篇文章<a href="https://koromon.github.io/2018/01/22/js原型链简介/">《js原型链简介》</a>后，我对原型链的理解也加深了不少，所以现在趁热打铁，继续来写一写 js 中的继承。</p>
<p>js 中的继承是通过原型链来实现的，常见的继承方式有如下几种：</p>
<h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>顾名思义，是通过构造函数来实现继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function People(age) &#123;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">People.prototype.run = function() &#123;</div><div class="line">	console.log(&apos;run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Man(name,age) &#123;</div><div class="line">	People.call(this,age); // 构造函数 People 中的 this 指向 Man 的实例</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line">var man = new Man(&apos;ming&apos;, 2);</div><div class="line"></div><div class="line">console.log(man); // &#123;age: 2, name: &quot;ming&quot;&#125;</div><div class="line"></div><div class="line">console.log(man instanceof Man); // true</div><div class="line">console.log(man instanceof People); // false</div><div class="line"></div><div class="line">console.log(man.constructor); // Man</div><div class="line"></div><div class="line">man.run(); // TypeError</div></pre></td></tr></table></figure>
<p>由此可见，借用构造函数继承是部分继承，只继承构造函数中的属性，却没有继承原型链上的属性。</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>原型链继承，把父类的实例赋值给子类的 <code>__proto__</code>，子类的实例可以通过原型链找到父类上的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function People() &#123;</div><div class="line">	this.age = 3;</div><div class="line">&#125;</div><div class="line">People.prototype.run = function() &#123;</div><div class="line">	console.log(&apos;run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Man(name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;</div><div class="line">Man.prototype = new People();</div><div class="line">var man = new Man(&apos;ming&apos;);</div><div class="line"></div><div class="line">console.log(man); // &#123;name: &quot;ming&quot;&#125;</div><div class="line">console.log(man.age); // 3</div><div class="line"></div><div class="line">console.log(man instanceof Man); // true</div><div class="line">console.log(man instanceof People); // true</div><div class="line"></div><div class="line">console.log(man.constructor); // People</div><div class="line"></div><div class="line">man.run(); // run</div></pre></td></tr></table></figure>
<p>原型链继承同样是部分继承，只继承了原型链上的属性，没有继承构造函数的属性。这个继承不仅无法修改父类中属性，同时会导致子类实例的 <code>constructor</code> 无法指向自身的构造函数。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>把构造函数继承和组合继承组合起来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function People(age) &#123;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">People.prototype.run = function() &#123;</div><div class="line">	console.log(&apos;run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Man(name,age) &#123;</div><div class="line">    People.call(this,age); // 第二次执行构造函数 People</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">Man.prototype = new People(); // 第一次执行构造函数 People</div><div class="line">var man = new Man(&apos;ming&apos;,4);</div><div class="line"></div><div class="line">console.log(man); // &#123;age: 4, name: &quot;ming&quot;&#125;</div><div class="line"></div><div class="line">console.log(man instanceof Man); // true</div><div class="line">console.log(man instanceof People); // true</div><div class="line"></div><div class="line">console.log(man.constructor); // People</div><div class="line"></div><div class="line">man.run(); // run</div></pre></td></tr></table></figure>
<p>组合继承是比较完美的继承方式，它是完全继承。但是它执行了两次构造函数，第一次执行的时候会把构造函数 <code>People</code> 中的属性赋值到 <code>Man</code> 的原型对象上，第二次执行构造函数会把构造函数 <code>People</code> 中的属性赋值到 <code>Man</code> 的实例上。同时这种方式会导致子类 <code>constructor</code> 属性无法指向自身的构造函数。</p>
<h3 id="组合继承优化"><a href="#组合继承优化" class="headerlink" title="组合继承优化"></a>组合继承优化</h3><p>既然组合继承会执行两次构造函数，那么我们只要减少一次就行。因为原型链继承本质是把父类的原型对象赋值给子类的原型对象即可，并不需要创建一个父类实例再赋值。所以我们从原型链入手。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function People(age) &#123;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line">People.prototype.run = function() &#123;</div><div class="line">	console.log(&apos;run&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Man(name,age) &#123;</div><div class="line">    People.call(this,age); </div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">// Man.prototype = People.prototype; 缺点：修改 Man 的原型对象会导致 People 的也发生变化</div><div class="line">Man.prototype = Object.create(People.prototype); // 缺点：子类实例的 constructor 没有正确指向子类构造函数</div><div class="line">Man.prototype.constructor = Man; // 手动赋值，修正指向</div><div class="line"></div><div class="line">var man = new Man(&apos;ming&apos;,4);</div><div class="line"></div><div class="line">console.log(man); // &#123;age: 4, name: &quot;ming&quot;&#125;</div><div class="line"></div><div class="line">console.log(man instanceof Man); // true</div><div class="line">console.log(man instanceof People); // true</div><div class="line"></div><div class="line">console.log(man.constructor); // Man</div><div class="line"></div><div class="line">man.run(); // run</div></pre></td></tr></table></figure>
<p>通过上面的优化，我们可以说完美的实现了继承的方式。只执行了一次父类构造函数，并且子类实例的 <code>constructor</code> 也能正确指向构造函数。</p>
<h3 id="Class-实现继承"><a href="#Class-实现继承" class="headerlink" title="Class 实现继承"></a>Class 实现继承</h3><p>这个是 ES6 语法糖，大大简化了实现继承的步骤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class People&#123;</div><div class="line">  constructor(age)&#123;</div><div class="line">    this.age = age;</div><div class="line">  &#125;</div><div class="line">  run() &#123;</div><div class="line">    console.log(&apos;run&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">class Man extends People &#123;</div><div class="line">  constructor(name,age) &#123;</div><div class="line">    super(age);</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let man = new Man(5,&apos;ming&apos;);</div><div class="line"></div><div class="line">console.log(man); // &#123;age: &quot;ming&quot;, name: 5&#125;</div><div class="line"></div><div class="line">console.log(man instanceof Man); // true</div><div class="line">console.log(man instanceof People); // true</div><div class="line"></div><div class="line">console.log(man.constructor); // Man</div><div class="line"></div><div class="line">man.run(); // run</div></pre></td></tr></table></figure>
<p>可以看到，和组合继承优化的效果是一样的，并且语义更加清晰。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/22/js原型链简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/22/js原型链简介/" itemprop="url">js原型链简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-22T16:44:32+08:00">
                2018-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><blockquote>
<p>我们创建的每个函数都有一个 <code>prototype</code>（属性），这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 <code>prototype</code> 属性，这个属性指向函数的<strong>原型对象</strong>。</p>
</blockquote>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote>
<p>在默认情况下，所有原型对象都会自动获得一个 <code>constructor</code> （构造函数）属性，这个属性包含一个指向 <code>prototype</code> 属性所在的函数的指针。</p>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 <code>constructor</code> 属性；至于其他方法，则都是从 Object 继承而来。</p>
</blockquote>
<h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><blockquote>
<p>当调用构造函数创建一个新实例后，该实例的内部将会包含一个指针 <code>[[Prototype]]</code>（内部属性），指向构造函数的原型属性（在浏览器中通过 <code>__proto__</code> 访问）。</p>
<p>这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</p>
</blockquote>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><h3 id="三个概念之间的关系"><a href="#三个概念之间的关系" class="headerlink" title="三个概念之间的关系"></a>三个概念之间的关系</h3><p>接下来我们通过书上的一段代码和图片来展示上面三个基础概念之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = &apos;Nicholas&apos;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &apos;Software Engineer&apos;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">  alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName(); //&apos;Nicholas&apos;</div><div class="line"></div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName(); //&apos;Nicholas&apos;</div><div class="line"></div><div class="line">alert(person1.sayName === person2.sayName); // true</div></pre></td></tr></table></figure>
<p>各个对象的关系可以用下图表示。</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/WX20180123-104228.png" alt=""></p>
<p>根据各个对象间的关系，我们可以得到下面的联系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log(Person.prototype.constructor === Person); // true</div><div class="line">console.log(person1.__proto__.constructor === Person); // true</div><div class="line">console.log(person1.__proto__ === Person.prototype); // true</div></pre></td></tr></table></figure>
<h3 id="prototype-和-proto-的区别"><a href="#prototype-和-proto-的区别" class="headerlink" title="prototype 和 __proto__ 的区别"></a>prototype 和 <code>__proto__</code> 的区别</h3><ul>
<li><code>prototype</code> 是函数才有的属性，而 <code>__proto__</code> 则是每个对象都有的属性。</li>
<li>函数也是对象，所以函数也有 <code>__proto__</code> 属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var Person = function()&#123;&#125;</div><div class="line">console.log(typeof Person.prototype);  // &apos;object&apos;</div><div class="line">console.log(typeof Person.__proto__);  // &apos;function&apos;</div><div class="line"></div><div class="line">var person = &#123;&#125;;</div><div class="line">console.log(typeof person.prototype);  // undefined</div><div class="line">console.log(typeof person.__proto__);  // &apos;object&apos;</div></pre></td></tr></table></figure>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象有三种方法，分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 第一种 </div><div class="line">var o1 = &#123;name: &apos;o1&apos;&#125;;</div><div class="line">var o11 = new Object(&#123;name: &apos;o11&apos;&#125;);</div><div class="line">// 第二种</div><div class="line">var Obt = function()&#123;this.name = &apos;o2&apos;&#125;;</div><div class="line">var o2 = new Obt();</div><div class="line">// 第三种</div><div class="line">var P = &#123;name: &apos;o3&apos;&#125;</div><div class="line">var o3 = Object.create(P);</div><div class="line"></div><div class="line">console.log(o1); // &#123;name: &quot;o1&quot;&#125;</div><div class="line">console.log(o11); // &#123;name: &quot;o11&quot;&#125;</div><div class="line">console.log(o2); // &#123;name: &quot;o2&quot;&#125;</div><div class="line">console.log(o3); // &#123;&#125;</div></pre></td></tr></table></figure>
<p>上面 <code>o3</code> 输出为 <code>{}</code> 可能会让人觉得奇怪，我们来看接下来的代码，分别展示了上面四个对象的 <code>__proto__</code> 指向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(o1.__proto__ === Object.prototype); //true</div><div class="line">console.log(o11.__proto__ === Object.prototype); //true</div><div class="line"></div><div class="line">console.log(o2.__proto__ === Obt); //true</div><div class="line"></div><div class="line">console.log(o3.__proto__ === Object.prototype); //false</div><div class="line">console.log(o3.__proto__ === P); //false</div></pre></td></tr></table></figure>
<p>由此可知，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external"><code>Object.create(obj)</code></a> 方法，把传入的对象作为新创建对象的原型对象。所以它本身是不具备属性的，需要通过原型链获取。</p>
<h3 id="如何构建原型链"><a href="#如何构建原型链" class="headerlink" title="如何构建原型链"></a>如何构建原型链</h3><blockquote>
<p>原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法。</p>
</blockquote>
<p>根据我们上面提到的概念，其实就是说，对象会通过 <code>__proto__</code> 访问超类的属性，如果对象本身没有该属性，就会通过 <code>__proto__</code> 这个链条一直向上访问，直到找到这个属性或者尽头（<code>null</code>）为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function People()&#123;&#125;</div><div class="line">function Man()&#123;&#125;</div><div class="line"></div><div class="line">Man.prototype = new People();</div><div class="line">var man = new Man();</div><div class="line"></div><div class="line">console.log(man.__proto__ === Man.prototype); // true</div><div class="line">console.log(man.__proto__.__proto__ === People.prototype); // true</div><div class="line">console.log(man.__proto__.__proto__.__proto__ === Object.prototype); // true</div><div class="line">console.log(man.__proto__.__proto__.__proto__.__proto__ === null); // true。原型链的尽头为 null</div></pre></td></tr></table></figure>
<p>所以也可以这么说，<span style="color:red">对象通过 <code>__proto__</code> 实现原型链，通过 <code>prototype</code> 实现继承。</span></p>
<p>上一小结中，使用了 new 操作符创建对象，这里也说下 new 的过程：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此 <code>this</code> 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>如果构造函数返回了一个对象，那么这个对象会取代 <code>new</code> 出来的结果，反之则返回前面创建的对象。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function People()&#123;</div><div class="line">  return &#123;&#125; // new 返回的对象</div><div class="line">&#125;</div><div class="line"></div><div class="line">var people = new People();</div><div class="line">console.log(people.__proto__ === People.prototype); // false</div><div class="line">console.log(people.__proto__ === Object.prototype); // true</div></pre></td></tr></table></figure>
<h2 id="Function-和-Object"><a href="#Function-和-Object" class="headerlink" title="Function 和 Object"></a>Function 和 Object</h2><p><code>instanceof</code> 的原理就是判断对象的 <code>__proto__</code> 属性和函数对象的 <code>prototype</code> 是不是同一个引用。（即只要是在一条原型链都返回 <code>true</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function People()&#123;&#125;</div><div class="line">function Man()&#123;&#125;</div><div class="line"></div><div class="line">Man.prototype = new People();</div><div class="line">var man = new Man();</div><div class="line"></div><div class="line">console.log(man instanceof Man); // true</div><div class="line">console.log(man instanceof People); // true</div><div class="line">console.log(man instanceof Object); // true</div></pre></td></tr></table></figure>
<p>翻译为代码，其实就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">man.__proto__.__proto__.... === XXX.prototype ?</div><div class="line">// 把 XXX 替换为 Man/People/Object，等式均成立</div></pre></td></tr></table></figure>
<p>接下来我们看这个奇怪的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(Function instanceof Object); //true</div><div class="line">console.log(Object instanceof Function); //true</div></pre></td></tr></table></figure>
<p>我们先来看看 <code>Function</code> 和 <code>Object</code> 之间的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(Function.prototype === Function.__proto__); //true</div><div class="line">console.log(Function.prototype === Object.__proto__); //true</div></pre></td></tr></table></figure>
<p>用图案表示：</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/WX20180123-142653.png" alt=""></p>
<p>可见 <code>Function.__proto__.__proto__ === Object.prototype</code>,而 <code>Object.__proto__ === Function.prototype</code>。所以就有了上的例子。</p>
<p><strong>同时这里有几点需要留意：</strong></p>
<ul>
<li>所有构造函数的 <code>constructor</code> 都指向 Function</li>
<li><code>Function</code> 的原型对象是一个特殊的匿名函数，这个匿名函数有 <code>__proto__</code> 属性并且指向 <code>Object.prototype</code>。 </li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>Object.prototype 是一个普通对象，这个对象是原型链的顶端。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof Object.prototype; // &quot;object&quot;</div><div class="line">console.log(Object.prototype.__proto__ === null); // true</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>内置的 <code>Object</code> 是一个函数对象，它由 <code>Function</code> 构造而成。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof Object; // &quot;function&quot;</div><div class="line">console.log(Object.__proto__ === Function.prototype); // true</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>内置的 <code>Function</code> 是一个函数对象，它由自己构造而成。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof Function; // &quot;function&quot;</div><div class="line">console.log(Function.__proto__ === Function.prototype); // true</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>函数也是对象</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(typeof Function.prototype.__proto__) === &quot;object&quot;; // true </div><div class="line">console.log(Function.prototype.__ptoto__ === Object.prototype); // true</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>每个对象都有 <code>__proto__</code> 属性，但是只有函数对象有 <code>prototype</code> 属性。（Function 的原型对象是一个特殊的匿名函数，没有 <code>prototype</code> 属性。）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;&#125;;</div><div class="line">var obj = &#123;&#125;;</div><div class="line"></div><div class="line">console.log(obj.__proto__ === Object.prototype);//true  </div><div class="line">console.log(obj.prototype === undefined);//true  </div><div class="line"></div><div class="line">console.log(Person.__proto__ === Function.prototype);//true  </div><div class="line">console.log(Person.prototype !== undefined);//true </div><div class="line"></div><div class="line">typeof(Function.prototype); // function</div><div class="line">console.log(Function.prototype.prototype === undefined); // true</div></pre></td></tr></table></figure>
</li>
<li><p>实例对象的 <code>__proto__</code> 属性指向构造函数的 <code>prototype</code> 属性。</p>
<pre><code>function Person(){}
var person = new Person();

console.log(person.__proto__ === Person.prototype); // true
console.log(Person.__proto__ === Function.prototype); // true，因为 function Person 也是 Function 的实例
</code></pre></li>
<li><p>原型链通过 <code>__proto__</code> 实现（向上查找），继承通过 <code>prototype</code> 实现（继承属性）。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/18/pre-commit-ESLint/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/18/pre-commit-ESLint/" itemprop="url">pre-commit&ESLint</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-18T14:58:07+08:00">
                2018-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h2><p>相信大家合作项目的时候也发现，每个人的代码风格都不一样。最常见的，就说空格是用 <code>Tab</code> 还是 <code>spaces</code>，每个间隔是 2/4 个空格这个问题。所以没理由为了统一每次都要更改自己的编辑器的配置吧。</p>
<p>所以我们可以通过配置 <code>.editorconfig</code> 这个文件，这个文件会帮助我们统一各个编辑器之间的代码风格（无论你编辑器的默认配置如何），这样当维护一个公用项目的时候，就再也不用调整你自己的编辑器配置了。</p>
<h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>相信现在的前端都早已听过 ESLint 的大名，但是之前在项目中一直没有使用过。为了让自己写的代码风格更好呢，我也就打算自己先学习一波了~</p>
<p>直接参考这篇文章<a href="https://segmentfault.com/a/1190000009077086?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">使用 VSCode + ESLint 实践前端编码规范</a>进行配置即可。</p>
<p>当然配置过程中还是遇到一些“坑”的：</p>
<p>1、我安装的是 airbnb 的规范，所以最后的配置文件是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">    &quot;extends&quot;: &quot;airbnb&quot;,</div><div class="line">    rules: &#123;</div><div class="line">      // 填上你自己需要覆盖的配置</div><div class="line">    &#125;,</div><div class="line">    &quot;env&quot;: &#123;</div><div class="line">      &quot;browser&quot;: true,</div><div class="line">      &quot;node&quot;: true,</div><div class="line">      &quot;es6&quot;: true</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里一开始还不知道如何配置自己的需求，后来发现直接添加 <code>rules</code> 对象编写就行了。。具体的配置呢，可以去<a href="http://eslint.cn/" target="_blank" rel="external">ESLint</a>官网查看。</p>
<p>2、配置好后，发现没有效果？？？一开始以为是路径没有配好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;eslint.options&quot;: &#123;</div><div class="line">    &quot;configFile&quot;: &quot;这里填写 .eslintrc.js 的路径&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>但是在我确定指明了 <code>.eslintrc.js</code> 的路径后，还是没有任何反应。然后发现控制台提示无法找到模块 <code>eslint-config-airbnb</code>，再往上翻信息，发现安装 airbnb 模块的时候有警告 <code>warn</code> 缺少 <code>eslint</code> 模块。<span style="color:red">所以 <code>eslint</code> 在全局安装后还是要在项目中安装的。</span>然后其实并不需要通过 <code>configFile</code> 指定 <code>.eslintrc.js</code> 的路径也行，因为它会在项目中逐渐往上一级找配置文件。</p>
<p>如果你有不想检测的文件夹，新建一个 <code>.eslintignore</code> 文件，在里面配置好相关路径（文件）即可。</p>
<h2 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h2><p>现在 ESLint 已经配置好了，但是还有一个问题，如果别人无视这些报错也是可以的。。。所以这里推荐<a href="(https://www.npmjs.com/package/pre-commit">pre-commit</a>)这款插件，使用说明参考文档即可。</p>
<p>这里看看我的配置，这样每次 <code>commit</code> 之前，都会执行 <code>lint</code> 和 <code>fix</code> 脚本，如果有 ESLint 报错的情况，都是无法成功 <code>commit</code> 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</div><div class="line">    &quot;lint&quot;: &quot;eslint .&quot;, // 检测全部文件</div><div class="line">    &quot;fix&quot;: &quot;eslint --fix .&quot; // 修复可以修复的文件</div><div class="line">  &#125;,</div><div class="line">  &quot;pre-commit&quot;: [</div><div class="line">    &quot;fix&quot;,</div><div class="line">    &quot;lint&quot;</div><div class="line">  ],</div></pre></td></tr></table></figure>
<p>当然咯，如果想要强制提交也是可以的 <code>git commit -m &#39;XXX&#39; --no-verify</code>。</p>
<p>这里我也遇到一个坑，之前尝试的时候不小心执行了 <code>pre-commit/uninstall.js</code>，结果导致每次 <code>commit</code> 的时候根本不会去判断是否报错，后来在这篇文章<a href="http://xiaoqiang730730.github.io/2016/11/04/pre-commit/" target="_blank" rel="external">pre-commit</a>发现原因。于是切换到 <code>pre-commit</code> 文件夹，执行 <code>node install.js</code> 即可。</p>
<p>好了~现在可以开始规范的编写代码啦。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/16/HTTP协议简单概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/16/HTTP协议简单概念/" itemprop="url">HTTP协议简单概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-16T15:55:58+08:00">
                2018-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>HTTP 协议是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW：World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>HTTP 基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）</p>
</blockquote>
<h2 id="HTTP-协议的主要特点"><a href="#HTTP-协议的主要特点" class="headerlink" title="HTTP 协议的主要特点"></a>HTTP 协议的主要特点</h2><h3 id="简单快速"><a href="#简单快速" class="headerlink" title="简单快速"></a>简单快速</h3><p>每个资源（URI）都是固定的，有统一的资源服务，只要输入对应的 URI 即可。客户向服务器请求服务时，只需传送请求方法和路径。</p>
<h3 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h3><p>通过一个 HTTP 协议可以完成不同数据类型的传输，正在传输的类型由Content-Type 加以标记。</p>
<h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><p>每次连接只处理一个请求。服务器处理完客户的请求，并且收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，可能导致每次连接传送的数据量增大。可以通过其他手段获取状态，比如 session）</p>
<h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><p>HTTP 报文由请求报文和响应报文组成。</p>
<h3 id="请求报文（Request）"><a href="#请求报文（Request）" class="headerlink" title="请求报文（Request）"></a>请求报文（Request）</h3><p>客户端发送一个 HTTP 请求到服务器的请求消息包括下面四个部分：</p>
<ul>
<li>请求行（HTTP方法、页面地址、HTTP协议以及版本）</li>
<li>请求头（key/value告诉服务端要什么东西）</li>
<li>空行（切分请求头和请求体，即使请求体为空，也要有空行）</li>
<li>请求体</li>
</ul>
<h3 id="响应报文（Response）"><a href="#响应报文（Response）" class="headerlink" title="响应报文（Response）"></a>响应报文（Response）</h3><p>服务器接收并处理客户端发过来的请求后会返回一个 HTTP 的响应消息。该响应消息包含四个部分：</p>
<ul>
<li>状态行（HTTP 协议版本号、状态码、状态消息）</li>
<li>消息报头（说明客户端要使用的一些附加消息）</li>
<li>空行</li>
<li>响应正文（服务器返回给客户端的文本信息）</li>
</ul>
<h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>
<ul>
<li>1xx：指示信息 - 表示请求已接收，继续处理</li>
<li>2xx：成功 - 表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向 - 要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误 - 请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误 - 服务器未能实现合法的请求</li>
</ul>
<p>常见状态码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">200 OK                        //客户端请求成功</div><div class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</div><div class="line">401 Unauthorized              //请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 </div><div class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</div><div class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</div><div class="line">500 Internal Server Error     //服务器发生不可预期的错误</div><div class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</div></pre></td></tr></table></figure>
<h2 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h2><p>HTTP1.0 定义了三种请求方法：</p>
<ul>
<li>GET<ul>
<li>请求指定的页面信息，并返回实体主体</li>
</ul>
</li>
<li>POST<ul>
<li>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</li>
</ul>
</li>
<li>HEAD <ul>
<li>类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
</ul>
</li>
</ul>
<p>HTTP1.1 新增了五种请求方法：</p>
<ul>
<li>OPTIONS<ul>
<li>允许客户端查看服务器的性能</li>
</ul>
</li>
<li>PUT<ul>
<li>从客户端向服务器传送的数据取代指定的文档的内容</li>
</ul>
</li>
<li>DELETE<ul>
<li>请求服务器删除指定的页面</li>
</ul>
</li>
<li>TRACE<ul>
<li>回显服务器收到的请求，主要用于测试或诊断</li>
</ul>
</li>
<li>CONNECT<ul>
<li>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</li>
</ul>
</li>
</ul>
<h3 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h3><ul>
<li>GET 在浏览器回退的时候是无害的，而 POST 会再次提交请求</li>
<li>GET 请求会被浏览器主动缓存，而 POST 不会（除非手动设置）</li>
<li>GET 请求参数会被完整保留在浏览器历史记录，而 POST 中的参数不会被保留</li>
<li>GET 请求在 URL 中传送的参数有长度限制，而 POST 没有限制</li>
<li>GET 参数通过 URL 传递，POST 放在 Request body 中</li>
<li>GET 没有 POST 安全，因为参数会直接暴露在 URL 上</li>
<li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式</li>
</ul>
<h2 id="持久连接（Keep-Alive）"><a href="#持久连接（Keep-Alive）" class="headerlink" title="持久连接（Keep-Alive）"></a>持久连接（Keep-Alive）</h2><p>HTTP 协议采用”请求-应答“模式，使用普通模式时，每个请求/应答客户和服务器都要新建一个链接，完成后立即断开连接（无连接）</p>
<p>采用 Keep-Alive 模式（持久连接）时，客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立链接。</p>
<p>这个模式从 HTTP1.1 版本开始支持</p>
<h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p>管线化通过持久连接完成，把全部请求一次性打包传送，然后把全部响应一次性打包返回。管线化不会影响响应返回的顺序，同时只有 GET 和 HEAD 请求才可以进行管线化。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 资源，以及服务器如何把 Web 资源传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="http://www.runoob.com/http/http-methods.html" target="_blank" rel="external">http://www.runoob.com/http/http-methods.html</a></p>
<p>2.<a href="https://www.jianshu.com/p/80e25cb1d81a" target="_blank" rel="external">关于HTTP协议，一篇就够了</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/15/JavaScript-DOM事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/JavaScript-DOM事件/" itemprop="url">JavaScript DOM事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T17:18:15+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-17%20%E4%B8%8B%E5%8D%8811.05.21.png" alt="大纲"></p>
<h3 id="理解事件流"><a href="#理解事件流" class="headerlink" title="理解事件流"></a>理解事件流</h3><p>事件流描述页面接收事件的顺序</p>
<ul>
<li>事件冒泡流（IE和现代浏览器），由最具体的元素传播到不具体的节点。建议使用</li>
<li>事件捕获流（现代浏览器），由不具体的节点到具体的节点</li>
</ul>
<p>全部浏览器都支持事件冒泡。</p>
<p><code>DOM2级事件</code>规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。</p>
<p>Tips: IE9及以上才全部实现 <code>DOM2级</code> 事件（事件流）。</p>
<h3 id="使用事件处理程序"><a href="#使用事件处理程序" class="headerlink" title="使用事件处理程序"></a>使用事件处理程序</h3><p>事件就是用户或者浏览器执行的某种动作，而响应某个事件的函数就叫做<strong>事件处理程序</strong>。</p>
<ul>
<li>HTML 事件处理程序<ul>
<li>就是在 HTML 直接写 JS，基本很少使用，耦合性太强</li>
</ul>
</li>
<li>DOM0 级事件处理程序<ul>
<li>获取元素后直接对元素 <code>ele.onxx</code> 进行函数赋值，可以通过 <code>ele.onxxx = null;</code> 删除事件，全部浏览器都支持，但每种事件只能绑定一种方法。</li>
<li>绑定的属性方法名要小写</li>
<li>事件处理程序会在冒泡阶段被处理</li>
<li><code>this</code> 指向元素的作用域</li>
</ul>
</li>
<li>DOM2 级事件处理程序<ul>
<li>接受三个参数（事件名/处理函数/布尔值 true为捕获，false为冒泡）<ul>
<li><code>addEventListener()</code></li>
<li><code>removeEventListener()</code>(无法移除匿名函数)</li>
</ul>
</li>
<li>可以添加多个事件处理程序，先添加的先执行。</li>
<li><code>this</code> 指的是元素作用域</li>
</ul>
</li>
<li>IE 事件处理程序<ul>
<li>IE9 之前只支持事件冒泡，所以 IE 事件处理程序是在冒泡阶段执行。只接受两个参数（<code>on</code> + 事件名/处理函数）<ul>
<li><code>attachEvent()</code></li>
<li><code>detachEvent()</code></li>
</ul>
</li>
<li>可以添加多个事件处理程序，后添加的先执行。</li>
<li><code>this</code> 指的是 <code>window</code></li>
</ul>
</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>触发 DOM 事件的时候产生的对象 <code>event</code>。</p>
<ul>
<li>DOM 中的事件对象（DOM0 &amp; DOM2）<ul>
<li>可以直接在事件处理程序中获取 <code>event</code></li>
<li>事件属性和方法如下<ul>
<li><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-15%20%E4%B8%8B%E5%8D%886.37.55.png" alt=""></li>
<li><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-15%20%E4%B8%8B%E5%8D%886.38.04.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips: 在事件处理程序内部，对象 <code>this</code> 始终等于 <code>currentTarget</code> 的值，而 <code>target</code> 只包含事件的实际目标。也就是说直接点击目标元素的时候，这三个值相等；如果点击父节点（比如 <code>body</code>）触发事件程序，此时 <code>this</code> 等于 <code>currentTarget</code>，而 <code>target</code> 元素指向真正的目标（比如 <code>body</code> 上的按钮）。</p>
<p>IE9 及以上/现代浏览器都支持 DOM 事件操作。</p>
</blockquote>
<ul>
<li>IE 中的事件对象（<code>IE9</code> 以下）<ul>
<li>DOM0 通过 <code>window</code> 可以访问 <code>event</code>，直接获取参数的 <code>event</code> 会是 <code>undefined</code></li>
<li><code>attachEvent()</code> 添加的事件对象(<code>event</code>)可以通过传入的参数直接获取也可以通过 <code>window</code> 获取</li>
<li>事件的属性和方法<ul>
<li><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-15%20%E4%B8%8B%E5%8D%886.46.13.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>attachEvent</code>中的 this 指向 <code>window</code>，所以此时 <code>this</code> 不等于 <code>event.srcElement</code>，更加建议使用 <code>event.srcElement</code> 获取事件目标。</p>
</blockquote>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li>DOM3 级别，重新定义了 DOM2 中的一些事件，也新增了一些事件。(了解常用的即可，其他可以上网查询，具体内容可以去 w3c 查看)<ul>
<li><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-15%20%E4%B8%8B%E5%8D%888.24.27.png" alt=""></li>
</ul>
</li>
</ul>
<blockquote>
<p>IE9 开始支持 DOM3 事件。</p>
</blockquote>
<h3 id="内存和性能"><a href="#内存和性能" class="headerlink" title="*内存和性能"></a>*内存和性能</h3><ul>
<li><p>事件委托</p>
<ul>
<li>利用事件冒泡，假设有多个元素要添加事件处理程序，那么可给他们的一个父类 <code>DOM</code> 元素添加事件处理程序（节省资源），再根据实际 <code>target</code> 对子类元素进行处理。</li>
<li>比较适合采用事件委托的事件（click/mousedown/mouseup/keydown/keyup/keypress）（这些事件都会冒泡，而且要有动作触发）</li>
</ul>
</li>
<li><p>移除事件和处理程序</p>
<ul>
<li>对于直接删除或者替代掉的 DOM 元素，要在移除之前先移除他们绑定的事件（remove/null）</li>
<li>通过 <code>onunload</code> 事件，统一移除所有事件处理程序。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Tips:如果使用了事件委托，就没那么麻烦，因为全部事件都只绑定在一个 <code>DOM</code> 上。</p>
</blockquote>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><ul>
<li>普通自定义事件（无法传参）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var eve = new Event(&apos;test&apos;);</div><div class="line">ev.addEventListener(&apos;test&apos;, () =&gt; &#123;</div><div class="line">	console.log(&apos;test dispatch&apos;)</div><div class="line">&#125;)</div><div class="line">ev.dispatchEvent(eve);</div></pre></td></tr></table></figure>
<ul>
<li><code>CustomEvent</code> 可以传递对象参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var eve = new CustomEvent(&apos;test&apos;, &#123;</div><div class="line">  &apos;detail&apos;: &#123;</div><div class="line">    a: &apos;aa&apos;,</div><div class="line">    b: &apos;bb&apos;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">ev.addEventListener(&apos;test&apos;, (e) =&gt; &#123;</div><div class="line">  console.log(e)</div><div class="line">&#125;)</div><div class="line">ev.dispatchEvent(eve);</div></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent" target="_blank" rel="external"><code>CustomEvent()</code></a> 创建自定义事件(现代浏览器基本支持)，合理使用可以减少 DOM 和事件之间的耦合性，提高代码复用效率，具体用法可以参考 MDN。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>从性能方面考虑，不要滥用事件处理程序。</li>
<li>可以多用事件委托技术。</li>
<li>浏览器卸载页面之前移除所有事件处理程序（目前来说这个应该不需要了，浏览器应该已经有处理了）</li>
<li>可以使用 js 模拟事件（这个要用的时候再搜索一下就足够了，目前先了解一下）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/15/《React-js-小书》学习-理解-React-redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/15/《React-js-小书》学习-理解-React-redux/" itemprop="url">《React.js 小书》学习 - 理解 React-redux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-15T16:15:16+08:00">
                2018-01-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="http://huziketang.com/books/react/" target="_blank" rel="external">React.js 小书原系列地址</a></p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>之前已经了解到，React.js 可以通过 context 设置‘全局变量’。这样父组件下的子组件就可以任意获取 context 中的变量，而不用一层层的进行状态提升。但是这样每个子组件都可以修改 context 会导致程序运行的不可预料。而在前一节<a href="https://koromon.github.io/2018/01/04/%E3%80%8AReact.js%20%E5%B0%8F%E4%B9%A6%E3%80%8B%E5%AD%A6%E4%B9%A0%20-%20%E7%90%86%E8%A7%A3%20Redux/">理解 Redux</a>中，我们了解到 store 是不会被随意修改的。于是我们考虑 context 和 store 进行结合。</p>
<p>在创建了 <code>store</code> 后，我们把它放到组件的 context 中。然后在子组件中获取 <code>store</code>，再进行和 Redux 类似的操作即可。</p>
<p>在这个过程中，我们发现每个子组件中会出现很多重复获取 context 的代码。此时我们可以实现一个高阶组件 <code>connect</code>，这个高阶组件获取 <code>mapStateToProps</code>（设置子组件需要的属性）、<code>mapDispatchToProps</code>（设置子组件需要的方法）以及 WrappedComponent（被包裹的子组件）三个参数，再把通过这前两个函数得到的内容通过 <code>props</code> 传回去给子组件。</p>
<p>最后我们再设置一个根组件（Provider），这个组件提供了 context 中的 <code>sotre</code>。</p>
<p>通过这样的设置，我们的组件都能抽离为 Dump 和 Smart 组件。在 Dump 组件中，我们不需要处理数据，只需要根据 Smart 组件中传入的 <code>props</code> 进行显示即可。所以这样的 Dump 组件是可以复用的。 而 Smart 组件则是用来执行特定应用逻辑的，不用考虑太多复用性问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/09/CSS盒模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/09/CSS盒模型/" itemprop="url">CSS盒模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-09T17:14:39+08:00">
                2018-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型指定元素如何显示以及（在某种程度上）如何交互。页面上的每个元素被看做一个矩形框（也称为元素框），这个框由元素的内容（Content）、内边距（Padding）、边框（Border）和外边距（Margin）组成。示意图如下：</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/box-model.gif" alt=""></p>
<p>在盒模型中，外边距可以为负值，但是内边距和边框不能为负值。而盒模型又分为两种模型。</p>
<h3 id="标准模型"><a href="#标准模型" class="headerlink" title="标准模型"></a>标准模型</h3><p>在标准模型中，CSS 中的 <code>width</code> 和 <code>height</code> 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。示意图如下：</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/CSS%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="盒模型"></p>
<h3 id="IE-模型"><a href="#IE-模型" class="headerlink" title="IE 模型"></a>IE 模型</h3><p>但是在 IE 盒模型（IE 早期浏览器）中，CSS 中的 <code>width</code> 和 <code>height</code> 指的是内容区域、内边距和变宽的宽度总和。示意图如下：</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/CSSIE%E6%A8%A1%E5%9E%8B.png" alt="IE模型"></p>
<h3 id="设置盒模型"><a href="#设置盒模型" class="headerlink" title="设置盒模型"></a>设置盒模型</h3><p>CSS3 中 <code>box-sizing</code> 属性可以定义使用哪种盒模型。</p>
<p><code>box-sizing:content-box;</code> 使用标准模型</p>
<p><code>box-sizing:border-box;</code> 使用 IE 模型</p>
<h3 id="JS-如何获取盒模型的宽高"><a href="#JS-如何获取盒模型的宽高" class="headerlink" title="JS 如何获取盒模型的宽高"></a>JS 如何获取盒模型的宽高</h3><ul>
<li>对于内联样式，可以通过： <code>dom.style.width/height</code></li>
<li>渲染后的节点样式，可以通过：<code>dom.currentStyle.width/height</code>（只有IE支持）</li>
<li>渲染后的节点式，可以通过： <code>window.getComputedStyle(dom).width/height</code> （高级浏览器）</li>
<li>渲染后的节点式，可以通过： <code>dom.getBoundingClientRect().width/height</code> （返回一个对象，包含元素宽/高，以及相对于视口左上角的 top/left/right/bottom）</li>
</ul>
<h3 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h3><p>当两个或更多垂直外边距相遇的时候，它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。</p>
<ul>
<li>常见的外边距叠加情形<ul>
<li>上下两个元素，第一个元素的底部外边距和第二个元素的顶部外边距叠加</li>
<li>当一个元素包含在另一个元素中（另一个元素没有设置内边距或者边框的时候）</li>
<li>一个空元素（没有设置内边距或者边框的时候），它本身的顶部和底部边距也会发生叠加。如果这个外边距继续和其他元素的外边距相遇，也会发生叠加。</li>
</ul>
</li>
</ul>
<h3 id="块级格式化上下文（Block-Formatting-Contexts）"><a href="#块级格式化上下文（Block-Formatting-Contexts）" class="headerlink" title="块级格式化上下文（Block Formatting Contexts）"></a>块级格式化上下文（Block Formatting Contexts）</h3><p>从样式上看，具有 BFC 的元素与普通的容器没有什么区别，但是从功能上，具有 BFC 的元素可以看作是隔离了的独立容器，他有一些普通容器没有的特性：</p>
<ul>
<li>独立的容器，不会和外部容器相互影响（内部元素不会在布局上影响到外面的元素）</li>
<li>垂直方向不会发生重叠</li>
<li>不会与浮动元素重叠</li>
<li>可以包含浮动元素（浮动元素也参与高度计算）。</li>
</ul>
<p>所以当我们不想发生边距重叠或者不希望和浮动元素重叠的时候，我们可以创建 BFC 元素。创建 BFC 元素有下面四种方法：</p>
<ul>
<li>浮动元素：<code>float</code> 除了 <code>none</code> 以外的值</li>
<li>定位元素 <code>position</code> 除了 <code>static</code>/<code>relative</code> 以外的值</li>
<li><code>display</code> 为 <code>inline-block</code>/<code>table-cell</code>/<code>table-caption</code> </li>
<li><code>overflow</code> 除了 <code>visible</code> 以外的值（<code>hidden</code>，<code>auto</code>，<code>scroll</code>）</li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1.<a href="https://www.cnblogs.com/leejersey/p/3991400.html" target="_blank" rel="external">《详说 Block Formatting Contexts (块级格式化上下文)》</a></p>
<p>2.<a href="http://blog.csdn.net/qq_30100043/article/details/73176546" target="_blank" rel="external">《js 获得盒子距离窗口的距离的集合的函数dom.getboundingclientrect()》</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/08/CSS圣杯布局和双飞翼布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/08/CSS圣杯布局和双飞翼布局/" itemprop="url">CSS圣杯布局和双飞翼布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-08T15:18:42+08:00">
                2018-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>圣杯布局和双飞翼布局都是为了解决两边定宽，中间自适应的三栏布局，也就是上篇文章中解决的第一种问题。</p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><h3 id="建立基本框架"><a href="#建立基本框架" class="headerlink" title="建立基本框架"></a>建立基本框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// HTML </div><div class="line">&lt;div class=&quot;header&quot;&gt;</div><div class="line">  header</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;div class=&quot;center column&quot;&gt;contianer-center&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;left column&quot;&gt;contianer-left&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;right column&quot;&gt;contianer-right&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;footer&quot;&gt;</div><div class="line">  footer</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">// CSS 样式</div><div class="line">.container &#123;</div><div class="line">  background: red;</div><div class="line">  padding-left: 200px;</div><div class="line">  padding-right: 150px;</div><div class="line">  .column &#123;</div><div class="line">    background: green;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先建立一个简单的结构。从下图可以看到，中间部分两边红色的地方就是 <code>padding</code> 撑开的区域。</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%885.08.48.png" alt="建立框架"></p>
<h3 id="调整三栏的样式"><a href="#调整三栏的样式" class="headerlink" title="调整三栏的样式"></a>调整三栏的样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.center &#123;</div><div class="line">  width: 100%; // 这个宽度是相对于父元素 container 的宽度</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">  width: 200px;</div><div class="line">  background: blue;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">  width: 150px;</div><div class="line">  background: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们给三栏分别设置宽度（宽度就是之前设置的 <code>padding</code>），然后设置浮动，最后要给 <code>.footer</code> 清除浮动，防止它向上移动至 <code>.header</code> 下方。</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%885.20.10.png" alt="给三栏设置样式"></p>
<p>此时可以看到，因为 <code>.center</code> 已经占满了一排，所以 <code>.left</code> 和 <code>.right</code> 被挤到了下面一排。而因为 <code>.container</code> 的子元素都是浮动的，导致它没有高度，所以背景色也看不到了。</p>
<h3 id="把左侧栏放上去"><a href="#把左侧栏放上去" class="headerlink" title="把左侧栏放上去"></a>把左侧栏放上去</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.left &#123;</div><div class="line">  ...</div><div class="line">  margin-left: -100%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们要用到负外边距这个属性，我们把 <code>.left</code> 的外边距设置为 <code>margin-left: -100%;</code>，因为第二排的 <code>padding-left</code> 只有 <code>200px</code> 的距离，所以只要 <code>margin-left</code> 大于等于这个距离，<code>.left</code> 元素就会往上移。随后 <code>.right</code> 元素会往左移动，代替 <code>.left</code> 的位置。</p>
<p><code>margin-left: -200px;</code>的时候<br><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%885.45.56.png" alt=""></p>
<p><code>margin-left: -100%;</code>的时候<br><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%885.46.32.png" alt=""></p>
<p>此时给 <code>.left</code> 设定一个相对定位，再设置 <code>left</code> 向左偏移 <code>200px</code> 即可；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.left &#123;</div><div class="line">  ...</div><div class="line">  position: relative;</div><div class="line">  left: -200px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%885.50.07.png" alt=""></p>
<h3 id="把右侧栏放上去"><a href="#把右侧栏放上去" class="headerlink" title="把右侧栏放上去"></a>把右侧栏放上去</h3><p>同左侧栏一样，通过下面的样式，可以把右侧栏也放上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.right &#123;</div><div class="line">  ...</div><div class="line">  position: relative;</div><div class="line">  margin-left: -150px;</div><div class="line">  right: -150px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时也有一种简单的写法，设置 <code>.right</code> 的负外边距。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.right &#123;</div><div class="line">  ...</div><div class="line">  margin-right: -150px; // 大于 .right 元素的宽度即可</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为 <code>.right</code> 创建了 BFC，所以其父元素的宽度等于 <code>.right</code> 的水平属性值之和，即外边距 + 内边距 + 边框宽度 + 宽度 = 父元素宽度。所以当 <code>.right</code> 的负外边距大于 <code>150px</code> 的时候，其父元素的宽度为 0，也就会挤上去第一排。</p>
<p><strong>注意</strong>：这里我们需要注意一下，其实此时 <code>.left</code> 和 <code>.right</code> 在文档流中都处于 <code>.center</code> 的右边框的位置。只是 <code>.left</code> 利用左负外边距，使得元素的左边不断左移，因此随着 <code>margin-left</code> 的减少，元素也就不断往左边偏移。而 <code>.right</code> 利用右负外边距，导致元素的右边不断左移，该值的不断减小并不会影响它左边所处的位置，所以无论 <code>margin-right</code> 如何减少，它都会固定在 <code>.center</code> 的右边。（这个观点是我个人理解，还未找出官方解释，如果有错欢迎指正。）</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%886.13.25.png" alt=""></p>
<p>此时可以发现圣杯布局已经完成了。</p>
<h3 id="设置最小宽度"><a href="#设置最小宽度" class="headerlink" title="设置最小宽度"></a>设置最小宽度</h3><p>如果我们缩小浏览器宽度，发现布局会错乱。</p>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%886.13.38.png" alt=""></p>
<p>我们需要设置 <code>.container</code> 的最小宽度，中间栏目的宽度必须保证最小 <code>200px</code>，因为 <code>.left</code> 是通过 <code>margin-left: -100%;</code> 来负边距移动的，这个父元素宽度也就是 <code>.center</code> 的 <code>width</code>，如果小于 <code>200px</code> 会导致 <code>.left</code> 无法挤上去。所以最终的最小宽度值为 <code>200px + 200px + 150px = 550px</code>。最后我们给 <code>body</code>（或者为它们的父元素） 添加上 <code>min-width: 550px</code> 即可。</p>
<p>完整代码：<a href="https://jsfiddle.net/77tLm944/" target="_blank" rel="external">https://jsfiddle.net/77tLm944/</a></p>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><h3 id="搭建框架"><a href="#搭建框架" class="headerlink" title="搭建框架"></a>搭建框架</h3><p>和圣杯布局一样，设置三个栏目为浮动元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// HTML</div><div class="line">&lt;div class=&quot;header&quot;&gt;</div><div class="line">  header</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;div class=&quot;main&quot;&gt;我是主面板&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;sub&quot;&gt;我是侧栏&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;extra&quot;&gt;我也是侧栏&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;div class=&quot;footer&quot;&gt;</div><div class="line">  footer</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">// CSS</div><div class="line">.main,</div><div class="line">.sub,</div><div class="line">.extra &#123;</div><div class="line">  float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.main &#123;</div><div class="line">  background: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.sub &#123;</div><div class="line">  background: green;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.extra &#123;</div><div class="line">  background: blue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%887.08.21.png" alt=""></p>
<h3 id="设置三栏样式"><a href="#设置三栏样式" class="headerlink" title="设置三栏样式"></a>设置三栏样式</h3><p>给主栏目设置 100% 宽度，其他两栏设置宽度后利用负边距分别挤上去第一排（原理和圣杯布局的一样）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">.main &#123;</div><div class="line">  ...</div><div class="line">  width: 100%;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.sub &#123;</div><div class="line">  ...</div><div class="line">  width: 200px;</div><div class="line">  margin-left: -100%;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.extra &#123;</div><div class="line">  ...</div><div class="line">  width: 150px;</div><div class="line">  margin-left: -150px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%887.11.40.png" alt=""></p>
<p>此时我们发现主栏的文字会被遮挡，因为此时侧栏只是单纯的覆盖在主栏上，没有做其他处理。此时为了让主栏的内容不被遮挡，我们可以考虑再在主栏里面放置一个元素标签。</p>
<h3 id="设置主栏样式"><a href="#设置主栏样式" class="headerlink" title="设置主栏样式"></a>设置主栏样式</h3><p>在主栏内部再新增一个容器，然后设置外边距。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;main&quot;&gt;</div><div class="line">  &lt;div class=&quot;main-wrapper&quot;&gt;我是主栏内容我是主栏内容我是主栏内容我是主栏内容我是主栏内容我是主栏内容我是主栏内容我是主栏内容我是主栏内容我是主栏内容我是主栏内容</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">.main-wrapper &#123;</div><div class="line">  margin-left: 200px;</div><div class="line">  margin-right: 150px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ouu4a4ldi.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-08%20%E4%B8%8B%E5%8D%888.32.22.png" alt=""></p>
<p>完整代码：<a href="https://jsfiddle.net/mLs0qve9/" target="_blank" rel="external">https://jsfiddle.net/mLs0qve9/</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>相同点</p>
<ul>
<li>这两种布局都实现了先加载主栏的内容</li>
<li>都使用了浮动布局，兼容性高</li>
<li>主栏宽度都设置 <code>100%</code></li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>圣杯布局使用内边距预留两侧栏空间，双飞翼布局给主栏里面的父元素设置外边距预留两侧栏空间</li>
<li>圣杯布局要设置最小宽度避免布局错乱。相对而言，双飞翼布局则不用太注意这点，只要页面宽度大于两侧栏宽度之和即可。</li>
<li>圣杯布局要设置相对定位，在设置 <code>left/right</code> 值，双飞翼布局不需要。</li>
</ul>
</li>
</ul>
<p>通过了解这两种布局方式，我觉得还是双飞翼布局的思路相对容易理解，并且样式也比较简洁。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol>
<li><a href="https://segmentfault.com/a/1190000004524159" target="_blank" rel="external">《关于「圣杯布局」》</a></li>
<li><a href="http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html" target="_blank" rel="external">CSS布局奇淫巧计之-强大的负边距</a></li>
<li><a href="http://www.cnblogs.com/langzs/archive/2013/01/27/taobaoshuangfeiyi.html" target="_blank" rel="external">CSS布局之–淘宝双飞翼布局</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://koromon.github.io/2018/01/05/常见三栏布局的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Feng Chenming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koromon's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/05/常见三栏布局的实现/" itemprop="url">常见三栏布局的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-05T11:18:45+08:00">
                2018-01-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>实现一个三栏布局，高度已知，中间宽度自适应，左右定宽的页面布局。</p>
</blockquote>
<p><a href="http://js.jirengu.com/vifisavubi/1/edit?html,css,output" target="_blank" rel="external">这里使用</a>了五种方式来解决上面的问题。分别是下面几种：</p>
<p>一、 浮动定位</p>
<p>浮动定位兼容性好，但是设置这种布局需要注意调整 <code>html</code> 中元素的位置。同时因为设置元素浮动会导致脱离文档流，所以必要的时候需要要清除浮动。</p>
<p>清除浮动有几种常见的方法</p>
<ul>
<li>在浮动元素的下方新增一个标签（<code>block/inline-block</code> 类型），然后该标签样式中使用 <code>clear:both</code>，因为要增加额外的元素，不推荐使用</li>
<li>浮动元素的父元素设置 <code>overflow:auto;</code>（这个可能会产生滚动条） 或者 <code>overflow:hidden;</code>（这个会导致超出的元素隐藏）</li>
<li><p>使用伪元素,只要给浮动元素的父元素添加相应的类名即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.clearfix:after &#123;</div><div class="line">　content: &apos;&apos;;</div><div class="line">　height: 0;</div><div class="line">　line-height: 0; /*或 overflow:hidden*/</div><div class="line">　display: block;</div><div class="line">　visibility: hidden;</div><div class="line">　clear: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>双伪元素，和上面的类似，但是写的属性不用那么多。推荐使用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.clearfix:before,</div><div class="line">.clearfix:after &#123;</div><div class="line">	content: &apos;&apos;;</div><div class="line">	display: table;</div><div class="line">&#125;</div><div class="line">.clearfix:after &#123;</div><div class="line">	clear: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>二、 绝对定位</p>
<p>绝对定位不需要特意调整 <code>html</code> 中的元素结构，但是同样会导致元素脱离文档流。需要注意对布局的影响。</p>
<p>三、 Flexbox</p>
<p>CSS3 中新增的布局样式，在目前来说，兼容性已经比较好了，尤其是移动端基本算是全部机型兼容了。Flexbox 布局很方便，要熟悉常见的属性，有助于提升开发效率。<a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="external">用法可以参考这里 - 理解Flexbox：你需要知道的一切</a>。</p>
<p>四、 table 布局</p>
<p>兼容性很好，而且它有个特性，就是强制每行中的每列都会等高，但是我再实际开发中比较少用到这种布局。在某些情况下这种布局也是一种很好解决方案。<a href="https://segmentfault.com/a/1190000007007885" target="_blank" rel="external">table布局的简单介绍</a></p>
<p>五、 Grid 布局</p>
<p>Grid 作为一种新的布局方式，兼容性上还不是很好，但是它把页面整体看做一个网格，使得我们可以随意摆放元素的位置。这种布局我在开发中还没用过，不过了解一下还是不错的。<a href="https://juejin.im/entry/5a23510f6fb9a0452a3c239f" target="_blank" rel="external">Grid 布局的简单介绍</a></p>
<p>综上所述，从兼容性和便利性的角度来说，Flexbox 是一种比较完美的布局方式。</p>
<hr>
<blockquote>
<p>接下来我们改一下布局要求：实现一个三栏布局，高度不定，中间宽度自适应，左右定宽的页面布局。</p>
</blockquote>
<p>一、 浮动定位，此时父元素的高度只会根据中间元素的高度固定，而浮动的左右两个元素因为脱离的文档流，无法获取父元素高度。此时两边的高度无法跟随父元素。</p>
<p>二、 绝对定位，此时三个元素都脱离文档流，父元素无法获取高度。无法实现</p>
<p>三、 Flexbox，左右两列会随着中间的高度变化而变化，可以实现。</p>
<p>四、 table 布局，因为 table 会强制同行的每列等高，所以可以实现。</p>
<p>五、 Grid 布局也可以实现。</p>
<p><a href="http://js.jirengu.com/zitiseracu/4/edit?html,css,output" target="_blank" rel="external">效果点此查看</a></p>
<hr>
<blockquote>
<p>接下来我们再改一下布局要求：实现一个三栏布局，总高度固定，上下高度固定，中间自适应。</p>
</blockquote>
<p>一、 浮动定位，无法实现</p>
<p>二、 绝对定位，可以实现。</p>
<p>三、 Flexbox，可以实现。</p>
<p>四、 table 布局，可以实现。</p>
<p>五、 Grid 布局，可以实现。</p>
<p><a href="http://js.jirengu.com/newimiqeyu/1/edit?html,css,output" target="_blank" rel="external">效果点此查看</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Feng Chenming</p>
              <p class="site-description motion-element" itemprop="description">we shall never surrender</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feng Chenming</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.3"></script>



  

  

  

  

  

  

</body>
</html>
